#include <std/assert>

typedef enum Color = {
    Red,
    Green,
    Blue,
    Rgb(int, int, int),
}

c1: Color = Red
c2: Color = Color.Green
c3: Color = Rgb(255, 0, 127)
c4: Color = Color.Rgb(0, 255, 255)

assert_eq!(c1, Color.Red)
assert_eq!(c2, Color.Green)
assert_ne!(c1, c2)

// the '=' after 'enum' keyword is optional
typedef enum Color2 {
    Red,
    Green,
    Blue,
}

assert_err!(Red) // 'Red' is ambiguous

typedef enum Rgb {
    Red(int),
    Green(int),
    Blue(int),
}

// here it knows because it has parameters
c := Red(255)

// to get the value from an enum

// option 1: force unwrap
c_value := c.unwrap()
assert_eq!(c_value, 255)

// option 2: pattern matching
match (c):
    Red(value) -> assert_eq!(value, 255),
    _ -> assert!(false, "Unexpected color"),
end

// more complex pattern matching
match (c3):
    Rgb(r, g, b) ->
        assert_eq!(r, 255)
        assert_eq!(g, 0)
        assert_eq!(b, 127)
    end
    _ -> assert!(false, "Unexpected enum variant"),
end

match (c4):
    Color.Rgb(r, g, b) ->
        assert_eq!(r, 0)
        assert_eq!(g, 255)
        assert_eq!(b, 255)
    end
    _ -> assert!(false, "Unexpected enum variant"),
end

// discriminants

// i have no idea for an example
typedef enum DiscriminantsTest = {
    Test1 = 1,
    Test69 = 69,
    Test2,  // auto 2 because it continues as it should
}

assert_eq!(DiscriminantsTest.Test1, DiscriminantsTest[1])
assert_eq!(DiscriminantsTest.Test69, DiscriminantsTest[69])
assert_eq!(DiscriminantsTest.Test2.discriminant(), 2)
