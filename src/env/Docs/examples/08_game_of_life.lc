#config debug = false

import time
import random
import collections  // for clear_terminal

// Conway's game of life in Lucia
// made by Markofwitch 2025, the developer of Lucia
// code inspired by https://github.com/mwharrisjr/Game-of-Life/
// Game originally created by John Conway in 1970

// glider
// small spaceship
final glider: list = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
]

// block
// still life
final block: list = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
]


// beacon
// period 2 oscillator
final beacon: list = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
]

// custom
// empty grid do whatever you want
final custom: list = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
]

fun createInitialGrid(rows: int, cols: int) -> list:
    // set use to null to get a random grid, or to one of the predefined patterns
    use: ?list = null
    if (use && len(use) == rows && len(use[0]) == cols):
        return use
    end
    grid: list = []
    for (row in [0..rows - 1]):
        rowList: list = []
        for (col in [0..cols - 1]):
            if (random.randint(0, 7) == 0):
                // append doesnt take a mutable ref so it returns a new list
                rowList = rowList.append(1)
            else:
                rowList = rowList.append(0)
            end
        end
        grid = grid.append(rowList)
    end
    return grid
end

fun printGrid(rows: int, cols: int, grid: list, generation: int) -> void:
    collections.clear_terminal()
    outputStr: str = "Generation " + str(generation) + " - To exit the program press <Ctrl-C>\n\r"
    for (row in [0..rows - 1]):
        for (col in [0..cols - 1]):
            if (grid[row][col] == 0):
                outputStr += ". "
            else:
                outputStr += "@ "
            end
        end
        outputStr += "\n\r"
    end
    print(outputStr, end="")
end

fun getLiveNeighbors(row: int, col: int, rows: int, cols: int, grid: list) -> int:
    lifeSum: int = 0
    for (i in [-1, 0, 1]):
        for (j in [-1, 0, 1]):
            if (!((i == 0) && (j == 0))):
                lifeSum += grid[(row + i + rows) % rows][(col + j + cols) % cols]
            end
        end
    end
    return lifeSum
end

// nested index access bug here
// using temp variables as a workaround
fun createNextGrid(rows: int, cols: int, grid: list) -> list:
    mutable temp: list = []
    // no list references so this is the RIGHT way
    nextGrid := array(rows, array(cols, 0))

    for (row in [0..rows - 1]):
        for (col in [0..cols - 1]):
            liveNeighbors: int = getLiveNeighbors(row, col, rows, cols, grid)

            if (liveNeighbors < 2 || liveNeighbors > 3):
                temp = nextGrid[row]
                temp[col] = 0
                nextGrid[row] = temp
                // nextGrid[row][col] = 0
            else if (liveNeighbors == 3 && grid[row][col] == 0):
                temp = nextGrid[row]
                temp[col] = 1
                nextGrid[row] = temp
                // nextGrid[row][col] = 1
            else:
                temp = nextGrid[row]
                temp[col] = grid[row][col]
                nextGrid[row] = temp
                // nextGrid[row][col] = grid[row][col]
            end
        end
    end

    return nextGrid
end

fun gridChanging(rows: int, cols: int, grid: list, nextGrid: list) -> bool:
    for (row in [0..rows - 1]):
        for (col in [0..cols - 1]):
            if (grid[row][col] != nextGrid[row][col]):
                return true
            end
        end
    end
    return false
end

fun getIntegerValue(prompt: str, low: int, high: int) -> int:
    while (true):
        print(prompt, end="")
        inputStr: str = input()
        try:
            value: int = int(inputStr)
        catch (e):
            print("Input was not a valid integer value.")
            continue
        end
        if (value < low || value > high):
            print("Input was not inside the bounds (value < " + str(low) + " or value > " + str(high) + ").")
            continue
        end
        return value
    end
end

fun runGame() -> void:
    collections.clear_terminal()
    print("Conway's Game of Life in Lucia\n")
    print("@ - live cell\n. - dead cell\n")
    rows: int = getIntegerValue("Enter the number of rows (10-60): ", 10, 60)
    cols: int = getIntegerValue("Enter the number of cols (10-118): ", 10, 118)

    generations: int = 5000

    currentGeneration: list = createInitialGrid(rows, cols)
    nextGeneration: ?list = null

    for (generation in [1..generations]):
        if nextGeneration isnt void:
            if (!gridChanging(rows, cols, currentGeneration, nextGeneration)):
                break
            end
        end
        printGrid(rows, cols, currentGeneration, generation)
        nextGeneration = createNextGrid(rows, cols, currentGeneration)
        // sleep is in MILLISECONDS for clarity because milliseconds are superior to seconds
        time.sleep(100)
        (currentGeneration, nextGeneration) = (nextGeneration, currentGeneration)
    end

    printGrid(rows, cols, currentGeneration, generations)
    print("<Enter> to exit or r to run again: ", end="")
    out: str = input()
    if (out == "r"):
        runGame()
    end
    null
end

runGame()
