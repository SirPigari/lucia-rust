import fs
import os.subprocess
import (os_name, os_arch) from os
import (max) from math

// Custom Language Compiler in Lucia
// made by Markofwitch 2025, the developer of Lucia
// NOTE: This is very slow and stupid

// disable debug printing, faster
#config debug = false
// for pointers
#config allow_unsafe = true

typedef enum Token {
    Ident(str),
    Number(str),
    String(str),
    BinaryOp(str),
    ParenOpen,
    ParenClose,
    BracketOpen,
    BracketClose,
    BraceOpen,
    BraceClose,
    Comma,
    Semicolon,
}

typedef enum ASTNode {
    BinOp(
        ASTNode,
        str,
        ASTNode,
    ),
    UnaryOp(str, ASTNode),
    Number(str),
    Print(ASTNode),
    String(str),
    While(ASTNode, ASTNode),
    If(ASTNode, ASTNode, ASTNode),
    VarDecl(str, ASTNode),
    VarAssign(str, ASTNode),
    Variable(str),
    Block(list[ASTNode]),
    ArrayLiteral(list[ASTNode]),
    IndexAccess(ASTNode, ASTNode),
    IndexWrite(ASTNode, ASTNode, ASTNode),
}

typedef enum SupportedPlatform {
    Linux_x86_64,
    Windows_x86_64,
}

fun tokenize(input: str) -> list[Token]:
    tokens: list[Token] = []
    i := 0
    while i < len(input):
        match input[i]:
            ' ' | '\t' | '\n': i++,
            '(':
                tokens.push(ParenOpen)
                i++
            end
            ')':
                tokens.push(ParenClose)
                i++
            end
            '[':
                tokens.push(BracketOpen)
                i++
            end
            ']':
                tokens.push(BracketClose)
                i++
            end
            '{':
                tokens.push(BraceOpen)
                i++
            end
            '}':
                tokens.push(BraceClose)
                i++
            end
            ',':
                tokens.push(Comma)
                i++
            end
            ';':
                tokens.push(Semicolon)
                i++
            end
            '/' if i + 1 < len(input) && input[i + 1] == '/' ->
                while i < len(input) && input[i] != '\n':
                    i++
                end
            end
            '+' | '-' | '*' | '/' | '%' | '=' | '!' | '<' | '>' | '&' | '|' ->
                if i + 1 < len(input) && (input[i + 1] == '=' || (input[i] == '&' && input[i + 1] == '&') || (input[i] == '|' && input[i + 1] == '|') || (input[i] == '<' && input[i + 1] == '<') || (input[i] == '>' && input[i + 1] == '>')):
                    tokens.push(BinaryOp(input[i..i + 2]))
                    i += 2
                else:
                    tokens.push(BinaryOp(input[i]))
                    i++
                end
            end
            '"':
                start := i + 1
                i += 1
                while i < len(input) && input[i] != '"':
                    i += 1
                end
                if i >= len(input):
                    throw "Unterminated string literal" from "SyntaxError",
                end
                tokens.push(Token.String(input[start..i]))
                i += 1
            end
            _ if input[i].isalpha() ->
                start := i
                while i < len(input) && input[i].isalnum():
                    i += 1
                end
                tokens.push(Ident(input[start..i]))
            end
            _ if input[i].isdigit() ->
                start := i
                while i < len(input) && input[i].isdigit():
                    i += 1
                end
                tokens.push(Token.Number(input[start..i]))
            end
            _ -> throw f"Unexpected character: {input[i]}" from "SyntaxError",
        end
    end
    return tokens
end

fun parse(tokens: list[Token]) -> list[ASTNode]:
    pos: &int = &0

    fun parse_primary() -> ASTNode:
        if *pos >= len(tokens):
            throw "Unexpected end of input" from "SyntaxError",
        end
        match tokens[*pos]:
            Token.Number(n) ->
                *pos += 1
                return ASTNode.Number(n)
            end
            Token.Ident(id) if id == "print" ->
                *pos += 1
                if *pos >= len(tokens) || tokens[*pos] != ParenOpen:
                    throw "Expected '('" from "SyntaxError"
                end
                (*pos) += 1
                expr := parse_expression()
                if *pos >= len(tokens) || tokens[*pos] != ParenClose:
                    throw f"Expected ')', found {tokens[*pos]}" from "SyntaxError"
                end
                (*pos) += 1
                return ASTNode.Print(expr)
            end
            Token.Ident(id) if id == "true" ->
                *pos += 1
                return ASTNode.Number("1")
            end
            Token.Ident(id) if id == "false" ->
                *pos += 1
                return ASTNode.Number("0")
            end
            Token.Ident(id) if id == "if" -> return parse_if(),
            Token.Ident(id) if id == "while" -> return parse_while(),
            Token.Ident(id) if id == "let" -> return parse_vardecl(),
            Token.Ident(id) ->
                if (*pos + 1 < len(tokens)) && tokens[*pos + 1] == BinaryOp("="):
                    name := id,
                    (*pos) += 2
                    expr := parse_expression()
                    return ASTNode.VarAssign(name, expr)
                else if (*pos + 1 < len(tokens) && tokens[*pos + 1] == BracketOpen):
                    var_node := ASTNode.Variable(id)
                    (*pos) += 2
                    
                    index_expr := parse_expression()

                    if (*pos >= len(tokens) || tokens[*pos] != BracketClose):
                        throw "Expected ']'" from "SyntaxError"
                    end
                    (*pos) += 1

                    if (*pos < len(tokens) && tokens[*pos] == BinaryOp("=")):
                        (*pos) += 1
                        value_expr := parse_expression()
                        return ASTNode.IndexWrite(var_node, index_expr, value_expr)
                    else:
                        return ASTNode.IndexAccess(var_node, index_expr)
                    end
                else:
                    (*pos) += 1
                    return ASTNode.Variable(id)
                end
            end
            Token.String(s) ->
                *pos += 1
                return ASTNode.String(s)
            end
            Token.ParenOpen ->
                *pos += 1
                expr := parse_expression()
                if (*pos >= len(tokens)) || (tokens[*pos] != ParenClose):
                    throw "Expected ')'" from "SyntaxError"
                end
                (*pos) += 1
                return expr
            end
            Token.ParenClose -> throw "Unexpected ')'" from "SyntaxError",
            Token.BraceOpen -> parse_block(),
            Token.BraceClose -> throw "Unexpected '}'" from "SyntaxError",
            Token.BracketOpen ->
                *pos += 1
                elements: list[ASTNode] = []

                if (*pos < len(tokens)) && (tokens[*pos] != Token.BracketClose):
                    first_expr := parse_expression()

                    if (*pos < len(tokens)) && (tokens[*pos] == Token.Semicolon):
                        (*pos) += 1
                        repeat_count := &1
                        match (parse_expression()):
                            ASTNode.Number(n) -> *repeat_count = n as int,
                            _ -> throw "Expected number for array repeat count" from "SyntaxError",
                        end
                        for _ in [0..*repeat_count]:
                            elements.push(first_expr)
                        end
                    else:
                        elements.push(first_expr)
                        while (*pos < len(tokens)) && (tokens[*pos] == Token.Comma):
                            (*pos) += 1
                            elements.push(parse_expression())
                        end
                    end
                end

                if (*pos >= len(tokens)) || (tokens[*pos] != Token.BracketClose):
                    throw "Expected ']'" from "SyntaxError"
                end

                (*pos) += 1
                return ASTNode.ArrayLiteral(elements)
            end
            Token.BracketClose -> throw "Unexpected ']'" from "SyntaxError",
            Token.BinaryOp(op) -> 
                match (op):
                    "+" | "-" | "!" ->
                        *pos += 1
                        expr := parse_primary()
                        return ASTNode.UnaryOp(op, expr)
                    end
                    _ -> throw f"Unexpected binary operator: {op}" from "SyntaxError",
                end
            end
            _ -> throw f"Expected primary expression, got {tokens[*pos]}" from "SyntaxError",
        end
    end

    fun parse_if() -> ASTNode:
        *pos += 1
        if *pos >= len(tokens) || tokens[*pos] != ParenOpen:
            throw "Expected '(' after if" from "SyntaxError"
        end
        (*pos) += 1
        cond := parse_expression()
        if *pos >= len(tokens) || tokens[*pos] != ParenClose:
            throw "Expected ')' after if condition" from "SyntaxError"
        end
        (*pos) += 1
        if *pos >= len(tokens) || tokens[*pos] != BraceOpen:
            throw "Expected '{' after if condition" from "SyntaxError"
        end
        (*pos) += 1
        then_body := parse_block()
        else_body: list[ASTNode] = []
        if (*pos < len(tokens)) && (tokens[*pos] == Ident("else")):
            (*pos) += 1
            if (*pos >= len(tokens)) || (tokens[*pos] != BraceOpen):
                throw "Expected '{' after else" from "SyntaxError"
            end
            (*pos) += 1
            else_body = match parse_block():
                ASTNode.Block(stmts) -> stmts,
                other -> [other],
            end
        end
        return ASTNode.If(cond, then_body, ASTNode.Block(else_body))
    end

    fun parse_while() -> ASTNode:
        *pos += 1
        cond := parse_expression()
        if *pos >= len(tokens) || tokens[*pos] != BraceOpen:
            throw "Expected '{' after while condition" from "SyntaxError"
        end
        (*pos) += 1
        body := parse_block()
        return ASTNode.While(cond, body)
    end

    fun parse_vardecl() -> ASTNode:
        *pos += 1
        if *pos >= len(tokens) || !(match tokens[*pos] from Token.Ident(_)):
            throw "Expected identifier after 'let'" from "SyntaxError"
        end
        match tokens[*pos]:
            Token.Ident(name) ->
                *pos += 1
                if (*pos >= len(tokens)) || (tokens[*pos] != Token.BinaryOp("=")):
                    throw "Expected '=' in variable declaration" from "SyntaxError"
                end
                (*pos) += 1
                expr := parse_expression()
                return ASTNode.VarDecl(name, expr)
            end
            _ -> throw "Invalid variable declaration" from "SyntaxError",
        end
    end

    fun parse_block() -> ASTNode:
        stmts: list[ASTNode] = []
        while ((*pos < len(tokens)) && (tokens[*pos] != BraceClose)):
            stmts.push(parse_expression())
        end
        if (*pos >= len(tokens)) || (tokens[*pos] != BraceClose):
            throw "Expected '}' at end of block" from "SyntaxError"
        end
        (*pos) += 1
        return ASTNode.Block(stmts)
    end

    fun parse_expression() -> ASTNode:
        left := parse_primary()
        m := true
        while ((*pos < len(tokens)) && m):
            match tokens[*pos]:
                BinaryOp(op) ->
                    *pos += 1
                    right := parse_primary()
                    left = ASTNode.BinOp(left, op, right)
                end
                _ -> m = false,
            end
        end
        return left
    end

    out: list[ASTNode] = []
    while *pos < len(tokens):
        out.push(parse_expression())
    end
    return out
end

fun compile_into_x86_64_asm_win(ast: list[ASTNode]) -> str:
    strings: &list = &[]
    asm := ""
    vars: &map = &{}
    rsp_offset: &int = &0
    label_count: &int = &0
    stack_size_approximate: &int = &0

    fun get_var_offset(name: str) -> int:
        if (!(*vars).contains_key(name)):
            throw f"Undefined variable: {name}" from "CompileError"
        end
        return (*vars)[name]
    end

    fun add_string(s: str) -> str:
        id := len(*strings)
        if (s in *strings):
            for ((i, existing) in (*strings).enumerate()):
                if existing == s:
                    return f"str_{i}"
                end
            end
        end
        (*strings) = (*strings).append(s)
        return f"str_{id}"
    end

    fun gen_label() -> str:
        label := f"label_{*label_count}"
        (*label_count) += 1
        return label
    end

    fun compile_node(node: ASTNode) -> str:
        match (node):
            ASTNode.Number(n) -> return f"    mov rax, {n}\n",
            ASTNode.String(s) ->
                label := add_string(s)
                return f"    lea rax, [rel {label}]\n"
            end
            ASTNode.UnaryOp(op, expr) ->
                inner := compile_node(expr)
                match (op):
                    "!": return inner +
                        "    cmp rax, 0\n" +
                        "    sete al\n" +
                        "    movzx rax, al\n",
                    "+": return inner,
                    "-": return inner + "    neg rax\n",
                    _ -> throw f"Unknown unary operator: {op}" from "CompileError",
                end
            end
            ASTNode.Print(expr) ->
                expr_asm := compile_node(expr)
                fmt := match (expr):
                    ASTNode.String(_) -> "fmt_str",
                    _ -> "fmt_int",
                end
                return expr_asm +
                    "    sub rsp, 32\n" +
                    f"    lea rcx, [rel {fmt}]\n" +
                    "    mov rdx, rax\n" +
                    "    call printf\n" +
                    "    add rsp, 32\n"
            end
            ASTNode.BinOp(left, op, right) ->
                left_asm := compile_node(left)
                right_asm := compile_node(right)
                return left_asm +
                    "    mov r10, rax\n" +
                    right_asm +
                    "    mov r11, rax\n" +
                    match (op):
                        "+":  "    mov rax, r10\n    add rax, r11\n",
                        "-":  "    mov rax, r10\n    sub rax, r11\n",
                        "*":  "    mov rax, r10\n    imul rax, r11\n",
                        "/":  "    mov rdx, 0\n    mov rax, r10\n    div r11\n",
                        "%":  "    mov rdx, 0\n    mov rax, r10\n    div r11\n    mov rax, rdx\n",
                        "==": "    mov rax, r10\n    cmp rax, r11\n    sete al\n    movzx rax, al\n",
                        "!=": "    mov rax, r10\n    cmp rax, r11\n    setne al\n    movzx rax, al\n",
                        ">":  "    mov rax, r10\n    cmp rax, r11\n    setg al\n    movzx rax, al\n",
                        "<":  "    mov rax, r10\n    cmp rax, r11\n    setl al\n    movzx rax, al\n",
                        ">=": "    mov rax, r10\n    cmp rax, r11\n    setge al\n    movzx rax, al\n",
                        "<=": "    mov rax, r10\n    cmp rax, r11\n    setle al\n    movzx rax, al\n",
                        "&&": "    mov rax, r10\n    and rax, r11\n",
                        "||": "    mov rax, r10\n    or rax, r11\n",
                        "<<": "    mov rcx, r11\n    mov rax, r10\n    shl rax, cl\n",
                        ">>": "    mov rcx, r11\n    mov rax, r10\n    shr rax, cl\n",
                        "|":  "    mov rax, r10\n    or rax, r11\n",
                        "&":  "    mov rax, r10\n    and rax, r11\n",
                        _ -> throw f"Unknown operator: {op}" from "CompileError",
                    end
                end
            ASTNode.VarDecl(name, expr) ->
                expr_asm := compile_node(expr)

                (*rsp_offset) += 8
                v := *vars
                v[name] = *rsp_offset,
                (*vars) = v,
                (*stack_size_approximate) = max(*stack_size_approximate, *rsp_offset)

                return expr_asm + f"    mov [rbp - {(*rsp_offset)}], rax    ; var {name} @ rbp - {(*rsp_offset)}\n"
            end
            ASTNode.Variable(name) ->
                if (!(*vars).contains_key(name)):
                    throw f"Undefined variable: {name}" from "CompileError"
                end
                offset := get_var_offset(name)
                return f"    mov rax, [rbp - {offset}]\n"
            end
            ASTNode.VarAssign(name, expr) ->
                if (!(*vars).contains_key(name)):
                    throw f"Undefined variable: {name}" from "CompileError"
                end
                expr_asm := compile_node(expr)
                offset := get_var_offset(name)
                return expr_asm + f"    mov [rbp - {offset}], rax\n"
            end
            ASTNode.Block(nodes) ->
                out := ""
                for n in nodes:
                    out += compile_node(n)
                end
                return out
            end
            ASTNode.If(cond, then_branch, else_branch) ->
                cond_asm := compile_node(cond)
                else_label := gen_label()
                end_label := gen_label()
                then_asm := compile_node(then_branch)
                else_asm := compile_node(else_branch)
                return cond_asm +
                       "    cmp rax, 0\n" +
                       f"    je {else_label}\n" +
                       then_asm +
                       f"    jmp {end_label}\n" +
                       f"{else_label}:\n" +
                       else_asm +
                       f"{end_label}:\n"
            end
            ASTNode.While(cond, body) ->
                start_label := gen_label()
                end_label := gen_label()
                return f"{start_label}:\n" +
                       compile_node(cond) +
                       "    cmp rax, 0\n" +
                       f"    je {end_label}\n" +
                       compile_node(body) +
                       f"    jmp {start_label}\n" +
                       f"{end_label}:\n"
            end
            ASTNode.ArrayLiteral(elements) ->
                count := len(elements)
                size := (count + 1) * 8

                inner := "    sub rsp, 32\n"
                inner += f"    mov rcx, {size}\n"
                inner += "    call malloc\n"
                inner += "    add rsp, 32\n"

                inner += f"    mov qword [rax], {count}\n"
                inner += "    lea rsi, [rax + 8]\n"

                inner += "    mov rbx, rax\n"

                all_zero := true
                for ((i, elem) in elements.enumerate()):
                    match (elem):
                        ASTNode.Number(n) if n == "0" -> end
                        _ -> all_zero = false,
                    end
                end

                if (all_zero):
                    inner += "    lea rdi, [rax + 8]    ; zero-initialized array\n"
                    inner += f"    mov rcx, {count}\n"
                    inner += "    xor rax, rax\n"
                    inner += "    rep stosq\n"
                    inner += "    mov rax, rbx\n"
                else:
                    for ((i, elem) in elements.enumerate()):
                        inner += "    push rsi\n"
                        inner += compile_node(elem)
                        inner += "    pop rsi\n"
                        inner += f"    mov [rsi + {8*i}], rax\n"
                    end

                    inner += "    mov rax, rbx\n"
                end
                return inner
            end
            ASTNode.IndexAccess(array_expr, index_expr) ->
                oob_label := gen_label()
                cont_label := gen_label()

                asm := ""
                match (array_expr):
                    ASTNode.Variable(name) ->
                        offset := get_var_offset(name)
                        asm += f"    mov r9, [rbp - {offset}]     ; var {name} @ rbp - {offset}\n"
                    end
                    _ ->
                        asm += compile_node(array_expr)
                        asm += "    mov r9, rax\n"
                    end
                end

                asm += compile_node(index_expr)
                asm += "    mov r8, rax\n"

                asm += "    mov rdx, [r9]\n"
                asm += "    cmp r8, 0\n"
                asm += f"    jl {oob_label}\n"
                asm += "    cmp r8, rdx\n"
                asm += f"    jae {oob_label}\n"

                asm += "    lea rax, [r9 + 8 + r8*8]\n"
                asm += "    mov rax, [rax]\n"
                asm += f"    jmp {cont_label}\n"

                asm += f"{oob_label}:\n"
                asm += "    sub rsp, 32\n"
                asm += "    lea rcx, [rel fmt_str]\n"
                asm += "    lea rdx, [rel oob_str]\n"
                asm += "    call printf\n"
                asm += "    add rsp, 32\n"
                asm += "    mov rcx, 1\n"
                asm += "    call exit\n"

                asm += f"{cont_label}:\n"
                return asm
            end
            ASTNode.IndexWrite(array_expr, index_expr, value_expr) ->
                oob_label := gen_label()
                cont_label := gen_label()

                asm := ""
                array_is_var := false
                offset2 := 0
                match (array_expr):
                    ASTNode.Variable(name) ->
                        offset2 = get_var_offset(name)
                        array_is_var = true
                        asm += f"    mov r9, [rbp - {offset2}]     ; var {name} @ rbp - {offset2}\n"
                    end
                    _ ->
                        asm += compile_node(array_expr)
                        asm += "    mov r9, rax\n"
                    end
                end

                asm += compile_node(index_expr)
                asm += "    mov r8, rax\n"

                asm += "    mov rdx, [r9]\n"
                asm += "    cmp r8, 0\n"
                asm += f"    jl {oob_label}\n"
                asm += "    cmp r8, rdx\n"
                asm += f"    jae {oob_label}\n"

                if (array_is_var):
                    asm += "    push r8\n"
                    asm += compile_node(value_expr)
                    asm += "    pop r8\n"
                    asm += f"    mov rdx, [rbp - {offset2}]\n"
                    asm += "    lea rdi, [rdx + 8 + r8*8]\n"
                else:
                    asm += "    push r9\n"
                    asm += "    push r8\n"
                    asm += compile_node(value_expr)
                    asm += "    pop r8\n"
                    asm += "    pop r9\n"
                    asm += "    lea rdi, [r9 + 8 + r8*8]\n"
                end
                asm += "    mov [rdi], rax\n"
                asm += f"    jmp {cont_label}\n"

                asm += f"{oob_label}:\n"
                asm += "    sub rsp, 32\n"
                asm += "    lea rcx, [rel fmt_str]\n"
                asm += "    lea rdx, [rel oob_str]\n"
                asm += "    call printf\n"
                asm += "    add rsp, 32\n"
                asm += "    mov rcx, 1\n"
                asm += "    call exit\n"

                asm += f"{cont_label}:\n"
                return asm
            end
            _ -> throw f"Unknown AST node: {node}" from "CompileError",
        end
    end

    gen_asm := ""
    for a in ast:
        gen_asm += compile_node(a)
    end

    stack_alloc := max((((*stack_size_approximate + 15) * 2) / 16) * 16, 1024)

    asm +=  "    push rbp\n"
    asm +=  "    mov rbp, rsp\n"
    asm += f"    sub rsp, {stack_alloc}\n"

    asm += gen_asm

    asm += "    sub rsp, 32\n"
    asm += "    mov rcx, 0\n"
    asm += "    call exit\n"

    data_section := "section .data\n" +
                    "fmt_str db \"%s\", 0\n" +
                    "fmt_int db \"%lld\", 10, 0\n" + 
                    "oob_str db \"Index out of bounds\", 0\n"

    externs := "extern printf\nextern malloc\nextern exit\n"

    for ((i, s) in (*strings).enumerate()):
        asm_repr := ""
        current_run := ""

        for ch in s:
            if (ch < ' ' or ch == 127):
                if current_run != "":
                    asm_repr += f"\"{current_run}\", "
                    current_run = ""
                end
                asm_repr += f"{ord(ch)}, "
            else:
                current_run += ch
            end
        end

        if current_run != "":
            asm_repr += f"\"{current_run}\", "
        end

        asm_repr += "0"

        data_section += f"str_{i} db {asm_repr}\n"
    end

    return externs +
           data_section +
           "section .text\nglobal main\nmain:\n" +
           asm
end

fun compile_into_x86_64_asm_linux(ast: list[ASTNode]) -> str:
    strings: &list = &[]
    asm := ""
    vars: &map = &{}
    rsp_offset: &int = &0
    label_count: &int = &0
    stack_size_approximate: &int = &0

    fun get_var_offset(name: str) -> int:
        if (!(*vars).contains_key(name)):
            throw f"Undefined variable: {name}" from "CompileError"
        end
        return (*vars)[name]
    end

    fun add_string(s: str) -> str:
        id := len(*strings)
        if (s in *strings):
            for ((i, existing) in (*strings).enumerate()):
                if existing == s:
                    return f"str_{i}"
                end
            end
        end
        (*strings).push(s)
        return f"str_{id}"
    end

    fun gen_label(name: str = "label") -> str:
        label := f"{name}_{*label_count}"
        (*label_count) += 1
        return label
    end

    fun compile_node(node: ASTNode) -> str:
        match (node):
            ASTNode.Number(n) -> return f"    mov rax, {n}\n",
            ASTNode.String(s) ->
                label := add_string(s)
                return f"    lea rax, [rel {label}]\n"
            end
            ASTNode.UnaryOp(op, expr) ->
                inner := compile_node(expr)
                match (op):
                    "!": return inner +
                        "    cmp rax, 0\n" +
                        "    sete al\n" +
                        "    movzx rax, al\n",
                    "+": return inner,
                    "-": return inner + "    neg rax\n",
                    _ -> throw f"Unknown unary operator: {op}" from "CompileError",
                end
            end
            ASTNode.Print(expr) ->
                expr_asm := compile_node(expr)
                match (expr):
                    ASTNode.String(_) ->
                        len_label := gen_label()
                        len_done := gen_label()
                        return expr_asm +
                            "    mov rdi, rax\n" +
                            "    xor rcx, rcx\n" +
                            f"{len_label}:\n" +
                            "    cmp byte [rdi + rcx], 0\n" +
                            f"    je {len_done}\n" +
                            "    inc rcx\n" +
                            f"    jmp {len_label}\n" +
                            f"{len_done}:\n" +
                            "    mov rsi, rdi\n" +
                            "    mov rdx, rcx\n" +
                            "    mov rax, 1\n" +
                            "    mov rdi, 1\n" +
                            "    syscall\n"
                    end
                    _ ->
                        conv_loop := gen_label()
                        conv_done := gen_label()
                        conv_zero := gen_label()
                        return expr_asm +
                            "    sub rsp, 64\n" +
                            "    mov rbx, rax\n" +
                            "    lea rsi, [rsp + 56]\n" +
                            "    cmp rbx, 0\n" +
                            f"    jne {conv_loop}\n" +
                            "    dec rsi\n" +
                            "    mov byte [rsi], '0'\n" +
                            f"    jmp {conv_done}\n" +
                            f"{conv_loop}:\n" +
                            "    xor rdx, rdx\n" +
                            "    mov rax, rbx\n" +
                            "    mov rcx, 10\n" +
                            "    div rcx\n" +
                            "    add dl, '0'\n" +
                            "    dec rsi\n" +
                            "    mov [rsi], dl\n" +
                            "    mov rbx, rax\n" +
                            "    cmp rbx, 0\n" +
                            f"    jne {conv_loop}\n" +
                            f"{conv_done}:\n" +
                            "    lea rax, [rsp + 56]\n" +
                            "    mov rdx, rax\n" +
                            "    sub rdx, rsi\n" +
                            "    mov rax, 1\n" +
                            "    mov rdi, 1\n" +
                            "    mov rsi, rsi\n" +
                            "    syscall\n" +
                            "    add rsp, 64\n"
                    end
                end
            end
            ASTNode.BinOp(left, op, right) ->
                left_asm := compile_node(left)
                right_asm := compile_node(right)
                return left_asm +
                       "    mov r10, rax\n" +
                       right_asm +
                       "    mov r11, rax\n" +
                       match (op):
                           "+": "    mov rax, r10\n    add rax, r11\n",
                           "-": "    mov rax, r10\n    sub rax, r11\n",
                           "*": "    mov rax, r10\n    imul rax, r11\n",
                           "/": "    xor rdx, rdx\n    mov rax, r10\n    div r11\n",
                           "%": "    xor rdx, rdx\n    mov rax, r10\n    div r11\n    mov rax, rdx\n",
                           "==": "    mov rax, r10\n    cmp rax, r11\n    sete al\n    movzx rax, al\n",
                           "!=": "    mov rax, r10\n    cmp rax, r11\n    setne al\n    movzx rax, al\n",
                           ">":  "    mov rax, r10\n    cmp rax, r11\n    setg al\n    movzx rax, al\n",
                           "<":  "    mov rax, r10\n    cmp rax, r11\n    setl al\n    movzx rax, al\n",
                           ">=": "    mov rax, r10\n    cmp rax, r11\n    setge al\n    movzx rax, al\n",
                           "<=": "    mov rax, r10\n    cmp rax, r11\n    setle al\n    movzx rax, al\n",
                           "&&": "    mov rax, r10\n    and rax, r11\n",
                           "||": "    mov rax, r10\n    or rax, r11\n",
                           "<<": "    mov rcx, r11\n    mov rax, r10\n    shl rax, cl\n",
                           ">>": "    mov rcx, r11\n    mov rax, r10\n    shr rax, cl\n",
                           "|":  "    mov rax, r10\n    or rax, r11\n",
                           "&":  "    mov rax, r10\n    and rax, r11\n",
                           _   -> throw f"Unknown operator: {op}" from "CompileError",
                       end
            end
            ASTNode.VarDecl(name, expr) ->
                expr_asm := compile_node(expr)

                (*rsp_offset) += 8
                v := *vars
                v[name] = *rsp_offset,
                (*vars) = v,
                (*stack_size_approximate) = max(*stack_size_approximate, *rsp_offset)

                return expr_asm + f"    mov [rbp - {(*rsp_offset)}], rax    ; var {name} @ rbp - {(*rsp_offset)}\n"
            end
            ASTNode.Variable(name) ->
                if (!(*vars).contains_key(name)):
                    throw f"Undefined variable: {name}" from "CompileError"
                end
                offset := get_var_offset(name)
                return f"    mov rax, [rbp - {offset}]\n"
            end
            ASTNode.VarAssign(name, expr) ->
                if (!(*vars).contains_key(name)):
                    throw f"Undefined variable: {name}" from "CompileError"
                end
                expr_asm := compile_node(expr)
                offset := get_var_offset(name)
                return expr_asm + f"    mov [rbp - {offset}], rax\n"
            end
            ASTNode.Block(nodes) ->
                out := ""
                for n in nodes:
                    out += compile_node(n)
                end
                return out
            end
            ASTNode.If(cond, then_branch, else_branch) ->
                cond_asm := compile_node(cond)
                else_label := gen_label()
                end_label := gen_label()
                then_asm := compile_node(then_branch)
                else_asm := compile_node(else_branch)
                return cond_asm +
                       "    cmp rax, 0\n" +
                       f"    je {else_label}\n" +
                       then_asm +
                       f"    jmp {end_label}\n" +
                       f"{else_label}:\n" +
                       else_asm +
                       f"{end_label}:\n"
            end
            ASTNode.While(cond, body) ->
                start_label := gen_label()
                end_label := gen_label()
                return f"{start_label}:\n" +
                       compile_node(cond) +
                       "    cmp rax, 0\n" +
                       f"    je {end_label}\n" +
                       compile_node(body) +
                       f"    jmp {start_label}\n" +
                       f"{end_label}:\n"
            end
            ASTNode.ArrayLiteral(elements) ->
                count := len(elements)
                size := (count + 1) * 8

                inner := "    sub rsp, 32\n"
                inner += f"    mov rdi, 0\n"
                inner += f"    mov rsi, {size}\n"
                inner += "    mov rdx, 3\n"          // PROT_READ|PROT_WRITE (0x03)
                inner += "    mov r10, 34\n"         // MAP_PRIVATE|MAP_ANONYMOUS (0x22)
                inner += "    mov r8, -1\n"
                inner += "    mov r9, 0\n"
                inner += "    mov rax, 9\n"
                inner += "    syscall\n"
                inner += "    add rsp, 32\n"

                inner += f"    mov qword [rax], {count}\n"
                inner += "    lea rsi, [rax + 8]\n"

                inner += "    mov rbx, rax\n"
                all_zero := true
                for ((i, elem) in elements.enumerate()):
                    match (elem):
                        ASTNode.Number(n) if n == "0" -> end
                        _ -> all_zero = false,
                    end
                end

                if (all_zero):
                    inner += "    mov rax, rbx           ; zero-initialized array\n"
                else:
                    for ((i, elem) in elements.enumerate()):
                        inner += "    push rsi\n"
                        inner += compile_node(elem)
                        inner += "    pop rsi\n"
                        inner += f"    mov [rsi + {8*i}], rax\n"
                    end

                    inner += "    mov rax, rbx\n"
                end
                return inner
            end
            ASTNode.IndexAccess(array_expr, index_expr) ->
                cont_label := gen_label()

                asm := ""
                match (array_expr):
                    ASTNode.Variable(name) ->
                        offset := get_var_offset(name)
                        asm += f"    mov r9, [rbp - {offset}]     ; var {name} @ rbp - {offset}\n"
                    end
                    _ ->
                        asm += compile_node(array_expr)
                        asm += "    mov r9, rax\n"
                    end
                end

                asm += compile_node(index_expr)
                asm += "    mov r8, rax\n"

                asm += "    mov rdx, [r9]\n"
                asm += "    cmp r8, 0\n"
                asm += f"    jl OOB\n"
                asm += "    cmp r8, rdx\n"
                asm += f"    jae OOB\n"

                asm += "    lea rax, [r9 + 8 + r8*8]\n"
                asm += "    mov rax, [rax]\n"
                asm += f"    jmp {cont_label}\n"

                // asm += f"{oob_label}:\n"
                // asm += "    lea rsi, [rel oob_str]\n"
                // asm += "    mov rdx, 19\n"  // length of "Index out of bounds"
                // asm += "    mov rax, 1\n"
                // asm += "    mov rdi, 1\n"
                // asm += "    syscall\n"
                // asm += "    mov rdi, 1\n"
                // asm += "    mov rax, 60\n"
                // asm += "    syscall\n"

                asm += f"{cont_label}:\n"
                return asm
            end
            ASTNode.IndexWrite(array_expr, index_expr, value_expr) ->
                cont_label := gen_label()

                asm := ""
                array_is_var := false
                offset2 := 0
                match (array_expr):
                    ASTNode.Variable(name) ->
                        offset2 = get_var_offset(name)
                        array_is_var = true
                        asm += f"    mov r9, [rbp - {offset2}]     ; var {name} @ rbp - {offset2}\n"
                    end
                    _ ->
                        asm += compile_node(array_expr)
                        asm += "    mov r9, rax\n"
                    end
                end

                asm += compile_node(index_expr)
                asm += "    mov r8, rax\n"

                asm += "    mov rdx, [r9]\n"
                asm += "    cmp r8, 0\n"
                asm += f"    jl OOB\n"
                asm += "    cmp r8, rdx\n"
                asm += f"    jae OOB\n"

                if (array_is_var):
                    asm += "    push r8\n"
                    asm += compile_node(value_expr)
                    asm += "    pop r8\n"
                    asm += f"    mov rdx, [rbp - {offset2}]\n"
                    asm += "    lea rdi, [rdx + 8 + r8*8]\n"
                else:
                    asm += "    push r9\n"
                    asm += "    push r8\n"
                    asm += compile_node(value_expr)
                    asm += "    pop r8\n"
                    asm += "    pop r9\n"
                    asm += "    lea rdi, [r9 + 8 + r8*8]\n"
                end
                asm += "    mov [rdi], rax\n"
                asm += f"    jmp {cont_label}\n"

                // asm += f"{oob_label}:\n"
                // asm += "    lea rsi, [rel oob_str]\n"
                // asm += "    mov rdx, 19\n"
                // asm += "    mov rax, 1\n"
                // asm += "    mov rdi, 1\n"
                // asm += "    syscall\n"
                // asm += "    mov rdi, 1\n"
                // asm += "    mov rax, 60\n"
                // asm += "    syscall\n"

                asm += f"{cont_label}:\n"
                return asm
            end
            _ -> throw f"Unknown AST node: {node}" from "CompileError",
        end
    end

    gen_asm := ""
    for a in ast:
        gen_asm += compile_node(a)
    end

    stack_alloc := max((((*stack_size_approximate + 15) * 2) / 16) * 16, 1024)

    asm +=  "    push rbp\n"
    asm +=  "    mov rbp, rsp\n"
    asm += f"    sub rsp, {stack_alloc}\n"

    asm += gen_asm

    asm += "    jmp OOB_SKIP\n"
    asm += f"OOB:                       ; Out Of Bounds label\n"
    asm += "    lea rsi, [rel oob_str]\n"
    asm += "    mov rdx, 19\n"  // length of "Index out of bounds"
    asm += "    mov rax, 1\n"
    asm += "    mov rdi, 1\n"
    asm += "    syscall\n"
    asm += "    mov rdi, 1\n"
    asm += "    mov rax, 60\n"
    asm += "    syscall\n"
    asm += "OOB_SKIP:                   ; Skip OOB if not called directly\n"
    asm += "    ; do nothing here\n\n"

    asm += "    ; Exit program\n"
    asm += "    sub rsp, 32\n"
    asm += "    mov rdi, 0\n"
    asm += "    mov rax, 60\n"
    asm += "    syscall\n"

    data_section := "section .data\n" +
                    "oob_str db \"Index out of bounds\", 0\n"

    for ((i, s) in (*strings).enumerate()):
        asm_repr := ""
        current_run := ""

        for ch in s:
            if (ch < ' ' or ch == 127):
                if current_run != "":
                    asm_repr += f"\"{current_run}\", "
                    current_run = ""
                end
                asm_repr += f"{ord(ch)}, "
            else:
                current_run += ch
            end
        end

        if current_run != "":
            asm_repr += f"\"{current_run}\", "
        end

        asm_repr += "0"

        data_section += f"str_{i} db {asm_repr}\n"
    end

    return data_section +
           "section .text\nglobal main\nmain:\n" +
           asm
end

fun compile(ast: list[ASTNode], platform: SupportedPlatform) -> str:
    match (platform):
        SupportedPlatform.Linux_x86_64 -> return compile_into_x86_64_asm_linux(ast),
        SupportedPlatform.Windows_x86_64 -> return compile_into_x86_64_asm_win(ast),
    end
end

fun main() -> void:
    cmd_str := styledstr("[CMD]", fg_color="blue")
    info_str := styledstr("[INFO]", fg_color="green")
    error_str := styledstr("[ERROR]", fg_color="red")

    input := '
// Rule 110 cellular automaton using bitwise rolling state

let steps = 100
let cells = [0; 100]
cells[99] = 1  // start at -1

while (steps > 0) {
    let i = 0
    while (i < 100) {
        if (cells[i] == 1) {
            print("#")
        } else {
            print(".")
        }
        i = i + 1
    }
    print("\n")

    let next = [0; 100]

    let state = (cells[99] << 2)
    state = state | (cells[0] << 1)
    state = state | cells[1]

    let i = 0
    while (i < 100) {
        next[i] = (110 >> state) & 1

        // update rolling state
        let left = cells[i]
        let right = cells[(i + 2) % 100]
        state = (state << 1) & 7
        state = state | right

        i = i + 1
    }

    cells = next
    steps = steps - 1
}
    '

    platform := match (os_name(), os_arch()):
        ("Linux", "x86_64"): SupportedPlatform.Linux_x86_64,
        ("Windows", "x86_64"): SupportedPlatform.Windows_x86_64,
        _ -> 
            println(f"{error_str} Sorry, unsupported platform: {os_name()} {os_arch()}")
            return 1
        end
    end

    if argv.contains("--target"):
        target_index := argv.index_of("--target") + 1
        if target_index >= len(argv):
            println(f"{error_str} '--target' requires an argument")
            return
        end
        target_str := argv[target_index].to_lower()
        match (target_str):
            "linux-x86_64": platform = SupportedPlatform.Linux_x86_64,
            "windows-x86_64": platform = SupportedPlatform.Windows_x86_64,
            _ -> 
                println(f"{error_str} Unknown target: {target_str}")
                return
            end
        end
    end

    println(f"{info_str} Detected platform: {platform}")

    if !subprocess.popen(["nasm", "--version"], capture_output=true).runned():
        match (platform):
            SupportedPlatform.Linux_x86_64 -> println(f"{error_str} 'nasm' is not installed."),
            SupportedPlatform.Windows_x86_64 -> println(f"{error_str} 'nasm' is not installed or not in PATH. Download from https://www.nasm.us/ and follow installation instructions."),
        end
        return
    end

    match (platform):
        SupportedPlatform.Linux_x86_64 -> if !subprocess.popen(["ld", "--version"], capture_output=true).runned():
            println(f"{error_str} 'ld' is not installed.")
            return
        end,
        SupportedPlatform.Windows_x86_64 -> if !subprocess.popen(["gcc", "--version"], capture_output=true).runned():
            println(f"{error_str} 'gcc' is not installed or not in PATH. Install MinGW-w64 from https://www.mingw-w64.org/downloads/ and follow installation instructions."),
            return
        end,
    end

    try:
        tokens := tokenize(input)
        println(f"{info_str} Tokenization complete, {len(tokens)} tokens found.")

        ast := parse(tokens)
        println(f"{info_str} Parsing complete, {len(ast)} AST nodes generated.")

        asm := compile(ast, platform)
        println(f"{info_str} Compilation complete, generated assembly code.")
    catch (em, er):
        println(f"{error_str} {em} ({er})")
        return
    end

    // println(f"Tokens: {tokens}")
    // println(f"AST: {ast}")
    // println(f"Assembly:\n{asm}")

    fs.write_file("output.asm", asm)
    println(f"{info_str} Assembly written to output.asm")
    println(f"{cmd_str} Running nasm to assemble...")
    if subprocess.run("nasm -felf64 output.asm -o output.o"):
        println(f"{error_str} Failed to assemble")
        return
    end
    match (platform):
        SupportedPlatform.Linux_x86_64 -> 
            println(f"{cmd_str} Running ld to link...")
            if subprocess.run("ld -o output output.o -nostdlib -static -e main"):
                println(f"{error_str} Failed to link executable")
                return
            end
        end
        SupportedPlatform.Windows_x86_64 -> 
            println(f"{cmd_str} Running gcc to link...")
            if subprocess.run("gcc output.o -o output"):
                println(f"{error_str} Failed to link executable")
                return
            end
        end
    end
    println(f"{info_str} Executable written to output")
end

main()
