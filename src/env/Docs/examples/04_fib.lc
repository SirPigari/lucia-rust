import math

fun fibonacci_recursive(n: int) -> int:
    if (n <= 1):
        return n
    end
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)
end

fun fibonacci_iterative(n: int) -> int:
    if (n <= 1):
        return n
    end

    a: int = 0
    b: int = 1    
    for (_ in [2..n]):
        (a, b) = (b, a + b)
    end
    return b
end

fun fibonacci_binet(n: int) -> int:
    phi: float = math.GOLDEN_RATIO
    psi: float = 1 - phi
    sqrt5: float = math.sqrt(5)

    num: float = phi ^ n - psi ^ n
    result: float = num / sqrt5

    return result as int
end

/*
Some Lucia pattern reg magic

it was supposed to be called pattern recognition but i misspelled it as pattern regocnition so from then on its called pattern reg

pattern reg is different than range (..) because it can generate more complex sequences like fibonacci, prime numbers, etc.

examples:
[1, 1, 2...; n + 1] // fibonacci sequence up to nth index
[1, 1, 2...55] // fibonacci sequence up to 55 (value 55 not index)

[1, 1, 2..; n + 1] // RangeError: Seed values do not have consistent step

(finally found a use to ';' in Lucia)
*/
fun fibonacci_pattern_reg(n: int) -> int:
    if (n <= 1):
        return n
    end
    l: list[int] = [0, 1, 1, 2...; n + 1]
    return l[n]
end


print(fibonacci_recursive(10))
print(fibonacci_iterative(10))
print(fibonacci_binet(10))
print(fibonacci_pattern_reg(10))