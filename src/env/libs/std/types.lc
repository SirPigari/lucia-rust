#ifndef LUCIA_STD_TYPES
#define LUCIA_STD_TYPES true

// aliases
public mutable typedef number = int | float
public mutable typedef primitive = int | float | bool | str | void
public mutable typedef ptr = &any

// character type
public final typedef Char[c] = str where (len(c) == 1)

// fixed-size types
public final typedef Int8[i]        = int where (-1 << 7 <= i && i <= (1 << 7) - 1)
public final typedef Int16[i]       = int where (-1 << 15 <= i && i <= (1 << 15) - 1)
public final typedef Int32[i]       = int where (-1 << 31 <= i && i <= (1 << 31) - 1)
public final typedef Int64[i]       = int where (-1 << 63 <= i && i <= (1 << 63) - 1)

public final typedef UInt8[i]       = int where (0 <= i && i <= (1 << 8) - 1)
public final typedef UInt16[i]      = int where (0 <= i && i <= (1 << 16) - 1)
public final typedef UInt32[i]      = int where (0 <= i && i <= (1 << 32) - 1)
public final typedef UInt64[i]      = int where (0 <= i && i <= (1 << 64) - 1)

public final typedef Float32[i]     = float where (i >= 2^-126 && i <= (2 - 2^-23) * 2^127)
public final typedef Float64 [i]    = float where (i >= 2^-1022 && i <= (2 - 2^-52) * 2^1023)
public final typedef Float128[i]    = float where (i >= 2^-16382 && i <= (2 - 2^-112) * 2^16383)

public final typedef Byte = UInt8

public final typedef Display = impl to_string[Self] -> str
public final typedef Clone   = impl clone[Self] -> Self

public final typedef Comparable = impl
    op_eq[Self, Self] -> bool +
    op_ne[Self, Self] -> bool +
    op_lt[Self, Self] -> bool +
    op_gt[Self, Self] -> bool +
    op_le[Self, Self] -> bool +
    op_ge[Self, Self] -> bool


public typedef enum Option<T> = {
    Some(T),
    None,
}
public typedef enum Result<T, E> = {
    Ok(T),
    Err(E),
}

public typedef enum Either<L, R> = {
    Left(L),
    Right(R),
}

private static final LUA_TABLE_PTR: &str = &"fucking luatic"

public typedef struct LuaTable<T> = {
    private mutable table: list[T],
}

for LuaTable:
    static fun new() -> Self:
        return LuaTable { table = [ LUA_TABLE_PTR ] }
    end

    static fun from_list(data: list[any]) -> Self:
        return LuaTable { table = [ LUA_TABLE_PTR ].extend(data) }
    end

    fun op_index(self, index: int) -> any:
        if (index < 0 || index >= len(self.table)):
            throw "Index out of bounds" from "IndexError"
        end
        return self.table[index]
    end

    // TODO: Implement 'op_index_set'
    fun op_index_set(mutable self, index: int, value: any):
        if (index < 0 || index >= len(self.table)):
            throw "Index out of bounds" from "IndexError"
        end
        self.table[index] = value
    end

    fun op_as(self, target_type: type) -> any:
        match (target_type.base_type()):
            list: self.table[1..],
            tuple: tuple(self.table[1..]),
            str: "".join(self.table[1..].map((v) => v.to_string()).collect()),
            any: self,
            bytes: "".join(self.table[1..].map((v) => v.to_string()).collect()) as bytes,
            _ -> throw "Cannot convert LuaTable to " + target_type from "TypeError",
        end
    end

    fun op_len(self) -> int:
        return (len(self.table) - 1)
    end

    fun push(mutable self, value: any):
        self.table = self.table.append(value)
    end
end

null

#endif