// std/macros.lc
// This file contains macros for the Lucia programming language's standard library.
#ifndef LUCIA_STD_MACROS
#define LUCIA_STD_MACROS
#include "./_import.lc"

// keep backwards compatibility
#include "./assert.lc"

#macro unreachable!($msg=("Entered unreachable code")):
    throw $msg from "UnreachableError"
#endmacro

#macro todo!($msg=("Feature not implemented yet")):
    throw $msg from "NotImplemented"
#endmacro

#macro dbg!($value...):
    // when a variadic arg in macros is used, the value of it isnt a tuple or a list, its just the values separated by commas
    // its on the macro to decide the type
    // here we use a list (denoted by the [])
    values: list = [$value]
    mutable output: str = ""  // output builder 
    for ((i, n) in values.enumerate()):
        // $!value means the stringified version of the value tokens
        // split by backticks to get the identifiers (backticks aren't used in lucia)
        output += $!`value.split("`")[i].trim() + " = " + _collections.format_value(n).trim() + "\n\r"
    end
    forget values
    print(output, end="")
    null  // otherwise it will return the last value (values)
#endmacro

#macro dbglog!($value):
    styledprint($value, fg_color=#config.color_scheme["debug"])
#endmacro

// uses ApolloTime from time module
#macro time_it!($expr):
    scope time_it_scope (_time): 
        start_time: int = _time.ApolloTime.now()
        result: any = ($expr)
        return ((result, start_time.elapsed()))
    end
#endmacro

#macro stringify!($value):
    if ($value is str):
        return $value
    else:
        return _collections.format_value($value)
    end
#endmacro

#macro stringify_tokens!($tokens):
    return $!tokens
#endmacro

// pattern must be a valid pattern (path) not a value
#macro matches!($value, $pattern):
    match $value from $pattern
#endmacro

#macro #no-mangle get_matched!($value, $pattern, $vars):
    match $value:
        $pattern -> true,
        _ -> false,
    end
    $vars
#endmacro

// just a quick macro so you don't have to worry about turning it to list
#macro sort![$val, $reverse=(false), $f=(null)]:
    lst: list = $val as list
    return lst.sort(reverse=$reverse, f=$f)
#endmacro

#macro mod!{$code}:
    import fs as _fs
    module_code: str = $!code
    tmp_file := _fs.temp_file()
    _fs.write_file(tmp_file, module_code)
    mod := module(tmp_file)
    _fs.delete_file(tmp_file)
    return mod
#endmacro

// return null
null

#endif